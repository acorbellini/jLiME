package edu.jlime.pregel.queues;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;

import org.mapdb.DB;
import org.mapdb.DBMaker;
import org.mapdb.HTreeMap;
import org.mapdb.Serializer;

import edu.jlime.pregel.mergers.MessageMergers.FloatMapDBMerger;
import edu.jlime.pregel.messages.FloatPregelMessage;
import edu.jlime.pregel.messages.PregelMessage;
import edu.jlime.pregel.worker.FloatData;
import edu.jlime.pregel.worker.WorkerTask;
import edu.jlime.pregel.worker.rpc.Worker;
import gnu.trove.map.hash.TObjectIntHashMap;

public class FloatMapDBQueue implements FloatMessageQueue {

	private static final int CACHE_SIZE = 1024;

	private HTreeMap<Long, Float> current;
	private HTreeMap<Long, Float> read;
	private FloatMapDBMerger merger;

	public FloatMapDBQueue(FloatMapDBMerger merger) {
		this.merger = merger;
		DB dbFile = DBMaker.tempFileDB().make();
		DB dbMem = DBMaker.memoryDB().make();

		HTreeMap onDisk = dbFile.hashMapCreate("onDisk")
				.keySerializer(Serializer.LONG)
				.valueSerializer(Serializer.FLOAT).make();

		// fast in-memory collection with limited size
		// its content is moved to disk, if not accessed for some time
		this.current = dbMem.hashMapCreate("inMemory")
				.expireMaxSize(CACHE_SIZE).expireOverflow(onDisk, true).make();

		HTreeMap readonDisk = dbFile.hashMapCreate("onDisk-2")
				.keySerializer(Serializer.LONG)
				.valueSerializer(Serializer.FLOAT).make();

		// fast in-memory collection with limited size
		// its content is moved to disk, if not accessed for some time
		this.read = dbMem.hashMapCreate("inMemory-2").expireMaxSize(CACHE_SIZE)
				.expireOverflow(readonDisk, true).make();
	}

	@Override
	public void switchQueue() {
		HTreeMap<Long, Float> aux = this.read;
		this.read = this.current;
		this.current = aux;
	}

	@Override
	public int currentSize() {
		return current.size();
	}

	@Override
	public int readOnlySize() {
		return read.size();
	}

	@Override
	public void flush(String msgType, WorkerTask workerTask) throws Exception {
		TObjectIntHashMap<Worker> sizes = new TObjectIntHashMap<>();
		{
			final Iterator<Long> it = read.keySet().iterator();
			while (it.hasNext()) {
				long to = it.next();
				if (to != -1) {
					Worker w = workerTask.getWorker(to);
					sizes.adjustOrPutValue(w, 1, 1);
				}
			}
		}

		HashMap<Worker, FloatData> ret = new HashMap<Worker, FloatData>();
		final Iterator<Entry<Long, Float>> it = read.entrySet().iterator();
		while (it.hasNext()) {
			Entry<Long, Float> entry = it.next();
			long to = entry.getKey();
			if (to == -1) {
				workerTask.outputFloat(msgType, -1l, -1l, entry.getValue());
			} else {
				Worker w = workerTask.getWorker(to);
				FloatData data = ret.get(w);
				if (data == null) {
					data = new FloatData(sizes.get(w));
					ret.put(w, data);
				}
				data.addL(to);
				data.addF(entry.getValue());
			}
		}
		read.clear();
		workerTask.sendFloats(msgType, ret);
	}

	@Override
	public Iterator<PregelMessage> getMessages(final String msgType,
			final long to) {
		final Float found = this.read.get(to);
		if (found == null)
			return null;
		else
			return new Iterator<PregelMessage>() {
				boolean first = true;

				@Override
				public PregelMessage next() {
					first = false;
					return new FloatPregelMessage(msgType, -1l, to, found);
				}

				@Override
				public boolean hasNext() {
					return first;
				}
			};
	}

	@Override
	public void putFloat(long from, long to, float msg) {
		Float found = this.current.putIfAbsent(to, msg);
		if (found != null) {
			this.current.put(to, merger.merge(found, msg));
		}
	}

}
