package edu.jlime.pregel.worker;

import gnu.trove.list.array.TLongArrayList;

import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;

import org.mapdb.BTreeMap;
import org.mapdb.DB;
import org.mapdb.DBMaker;
import org.mapdb.Fun;
import org.mapdb.Fun.Tuple2;

public class PersistentOrderedQueue {
	// AtomicLong messageID = new AtomicLong(0);

	// public static class MessageID implements Serializable,
	// Comparable<MessageID> {
	// long vid;
	// long messageid;
	//
	// public MessageID(long id, long mid) {
	// this.vid = id;
	// this.messageid = mid;
	// }
	//
	// @Override
	// public int compareTo(MessageID o) {
	// int comp = Long.compare(vid, o.vid);
	// if (comp == 0)
	// return Long.compare(messageid, o.messageid);
	// return comp;
	// }
	// }

	AtomicInteger readcont = new AtomicInteger(0);
	Semaphore rlock = new Semaphore(1);
	Semaphore wlock = new Semaphore(1);

	AtomicInteger cont = new AtomicInteger(0);
	AtomicInteger contBacked = new AtomicInteger(0);
	// private volatile TLongObjectHashMap<List<PregelMessage>> cache = new
	// TLongObjectHashMap<>();

	private volatile BTreeMap<Fun.Tuple2<Long, Long>, PregelMessage> cache;
	private volatile BTreeMap<Fun.Tuple2<Long, Long>, PregelMessage> back;
	private int max;
	private int initSize;
	private MessageMerger merger;

	public PersistentOrderedQueue(MessageMerger merger, int max,
			int initialListSize) {
		this.merger = merger;
		this.max = max;
		this.initSize = initialListSize;
		DB make = DBMaker.newTempFileDB().transactionDisable()
				.asyncWriteEnable().cacheDisable().make();
		this.back = make.createTreeMap("")
				.<Fun.Tuple2<Long, Long>, PregelMessage> make();

		DB makeMem = DBMaker.newMemoryDB().transactionDisable()
				.asyncWriteEnable().cacheDisable().make();
		this.cache = makeMem.createTreeMap("")
				.<Fun.Tuple2<Long, Long>, PregelMessage> make();
		// .valueSerializer(new Serializer<PregelMessage>() {
		//
		// @Override
		// public PregelMessage deserialize(DataInput input, int size)
		// throws IOException {
		// PregelMessage.read();
		// return ;
		// }
		//
		// @Override
		// public int fixedSize() {
		// return 0;
		// }
		//
		// @Override
		// public void serialize(DataOutput arg0, PregelMessage arg1)
		// throws IOException {
		// // TODO Auto-generated method stub
		//
		// }
		//
		// })

	}

	public void put(PregelMessage pregelMessage) {
		if (cont.get() > max) {
			contBacked.incrementAndGet();
			back.put(new Fun.Tuple2<Long, Long>(pregelMessage.getFrom(),
					pregelMessage.getTo()), pregelMessage);
		} else {

			if (merger != null) {
				long to = pregelMessage.getTo();
				Tuple2<Long, Long> tuple2 = new Fun.Tuple2<Long, Long>(-1l, to);
				PregelMessage msg = cache.get(tuple2);
				if (msg == null) {
					cache.put(tuple2, pregelMessage);
					int i = cont.incrementAndGet();
					if (i % 10000 == 0)
						System.out.println("current count: " + i);
				} else {
					GenericPregelMessage genericPregelMessage = new GenericPregelMessage(
							-1, to, null);
					merger.merge(msg, pregelMessage, genericPregelMessage);

					cache.put(tuple2, genericPregelMessage);
				}
			} else {
				long from = pregelMessage.getFrom();
				long to = pregelMessage.getTo();
				Tuple2<Long, Long> tuple2 = new Fun.Tuple2<Long, Long>(from, to);
				cache.put(tuple2, pregelMessage);
			}
		}
	}

	public void clear() {
		cache.clear();
		if (contBacked.get() > 0)
			back.clear();
		cont.set(0);
		contBacked.set(0);
	}

	public Iterator<List<PregelMessage>> iterator() {
		Iterator<Entry<Fun.Tuple2<Long, Long>, PregelMessage>> backIt = null;
		if (contBacked.get() > 0)
			backIt = back.entrySet().iterator();
		TLongArrayList list = new TLongArrayList();
		for (Tuple2<Long, Long> t : cache.keySet()) {
			list.add(t.b);
		}
		list.sort();
		return new PersistentQueueIterator(backIt, list, cache);
	}

	public int size() {
		return cont.get();
	}
}
