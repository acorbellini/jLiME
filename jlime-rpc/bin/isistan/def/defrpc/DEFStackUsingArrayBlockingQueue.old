package isistan.def.defrpc;

import isistan.def.defrpc.data.DataProcessor;
import isistan.def.defrpc.data.DataProvider;
import isistan.def.defrpc.discovery.DiscoveryProvider;
import isistan.def.defrpc.discovery.MCastDiscovery;
import isistan.def.defrpc.fd.FailureProvider;
import isistan.def.defrpc.fd.PingFailureDetect;
import isistan.def.defrpc.fr.DEFAck;
import isistan.def.defrpc.frag.DEFFrag;
import isistan.def.defrpc.message.AddressType;
import isistan.def.defrpc.message.DEFAddress;
import isistan.def.defrpc.message.DEFStackElement;
import isistan.def.defrpc.multi.MultiInterface;
import isistan.def.defrpc.np.Streamer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.UUID;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

public class DEFStack {
	private List<DEFStackElement> stackElements = new ArrayList<>();
	private FailureProvider fail;
	private DiscoveryProvider disco;
	private DataProcessor data;
	private Streamer streamer;
	private HashMap<String, Bus> buses = new HashMap<>();

	public void start() throws Exception {

		for (DEFStackElement m : stackElements) {
			m.start();
		}
	}

	public void addProc(DEFStackElement p) {
		p.addBus(this);
		stackElements.add(p);
	}

	public void cleanupOnFailedPeer(DEFAddress peer) {
		for (ListIterator<DEFStackElement> iterator = stackElements
				.listIterator(stackElements.size()); iterator.hasPrevious();) {
			DEFStackElement listElement = iterator.previous();
			listElement.cleanupOnFailedPeer(peer);
		}
	}

	public void stop() throws Exception {
		for (DEFStackElement m : stackElements) {
			m.stop();
		}
	}

	public static DEFStackUsingArrayBlockingQueue newStack(DEFStackElement... elements) {
		DEFStackUsingArrayBlockingQueue ret = new DEFStackUsingArrayBlockingQueue();
		for (DEFStackElement defStackElement : elements)
			ret.addProc(defStackElement);

		return ret;
	}

	private void setStreamer(Streamer s) {
		this.streamer = s;
	}

	private void setData(DataProcessor data) {
		this.data = data;
	}

	private void setDisco(MultiDiscovery disco) {
		this.disco = disco;
	}

	private void setFD(PingFailureDetect fail) {
		this.fail = fail;
	}

	public DataProvider getDataProvider() {
		return data;
	}

	public Streamer getStreamer() {
		return streamer;
	}

	public DiscoveryProvider getDiscovery() {
		return disco;
	}

	public FailureProvider getFailureDetection() {
		return fail;
	}

	public static DEFStackUsingArrayBlockingQueue tcpStack(DEFConfiguration config, UUID localID) {

		NetworkProtocolFactory udpFactory = NetworkProtocolFactory.udp(localID,
				config);

		NetworkProtocolFactory tcpFactory = NetworkProtocolFactory.tcp(localID,
				config);

		NetworkProtocolFactory mcastFactory = NetworkProtocolFactory.mcast(
				localID, config);

		// MultiInterface udp = MultiInterface.create(AddressType.UDP, config,
		// udpFactory);

		MultiInterface tcp = MultiInterface.create(AddressType.TCP, config,
				tcpFactory);

		MultiInterface mcast = MultiInterface.create(AddressType.MCAST, config,
				mcastFactory);

		DataProcessor data = new DataProcessor(tcp);

		MultiDiscovery disco = new MultiDiscovery();
		MCastDiscovery mcastDisco = new MCastDiscovery(localID, config, mcast,
				tcp);
		mcastDisco.addAddressListProvider(tcp);
		mcastDisco.addAddressListProvider(mcast);
		disco.addDisco(mcastDisco);

		PingFailureDetect fail = new PingFailureDetect(tcp);
		fail.addPingProvider(tcp);

		DEFStackUsingArrayBlockingQueue tcpStack = DEFStackUsingArrayBlockingQueue.newStack(tcp,
		// udp,
				mcast, data, disco, fail);
		tcpStack.setFD(fail);
		tcpStack.setDisco(disco);
		tcpStack.setData(data);
		tcpStack.setStreamer(tcp);
		return tcpStack;
	}

	public static DEFStackUsingArrayBlockingQueue udpStack(DEFConfiguration config, UUID id) {

		NetworkProtocolFactory udpFactory = NetworkProtocolFactory.udp(id,
				config);

		NetworkProtocolFactory tcpFactory = NetworkProtocolFactory.tcp(id,
				config);

		NetworkProtocolFactory mcastFactory = NetworkProtocolFactory.mcast(id,
				config);

		MultiInterface udp = MultiInterface.create(AddressType.UDP, config,
				udpFactory);

		MultiInterface tcp = MultiInterface.create(AddressType.TCP, config,
				tcpFactory);

		MultiInterface mcast = MultiInterface.create(AddressType.MCAST, config,
				mcastFactory);

		// DEFMessageBundler bundler = new DEFMessageBundler(udp,
		// config.max_msg_size);

		DEFAck ack = new DEFAck(udp, config.max_msg_size, config.nack_delay,
				config.ack_delay);

		DEFFrag frag = new DEFFrag(ack, config.max_msg_size);

		DataProcessor data = new DataProcessor(frag);

		MultiDiscovery disco = new MultiDiscovery();

		MCastDiscovery mcastDisco = new MCastDiscovery(id, config, mcast, udp);

		mcastDisco.addAddressListProvider(udp);
		mcastDisco.addAddressListProvider(tcp);
		disco.addDisco(mcastDisco);

		PingFailureDetect fail = new PingFailureDetect(udp);
		fail.addPingProvider(tcp);

		DEFStackUsingArrayBlockingQueue tcpStack = DEFStackUsingArrayBlockingQueue.newStack(tcp, udp,
		// bundler,
				ack, frag, mcast, data, disco, fail);
		tcpStack.setFD(fail);
		tcpStack.setDisco(disco);
		tcpStack.setData(data);
		tcpStack.setStreamer(tcp);
		return tcpStack;
	}

	public interface BusAction extends Runnable {
		public void run();
	}

	public static class Bus {
		private ExecutorService exec = Executors.newFixedThreadPool(5,
				new ThreadFactory() {
					@Override
					public Thread newThread(Runnable r) {
						Thread t = Executors.defaultThreadFactory()
								.newThread(r);
						t.setName("Bus Thread Pool");
						return t;
					}
				});

		private volatile boolean stopped = false;

		// private RingQueue in = new RingQueue();

		// private RingQueue out = new RingQueue();

		private ArrayBlockingQueue<BusAction> in = new ArrayBlockingQueue<BusAction>(
				1024);

		private ArrayBlockingQueue<BusAction> out = new ArrayBlockingQueue<BusAction>(
				1024);

		public Bus() {
			Thread tIn = new Thread("Bus in") {
				public void run() {
					while (!stopped) {
						// Object[] els = in.get();
						// if (stopped)
						// return;
						// for (Object object : els) {
						// out.add(object);
						// }
						try {
							out.put(in.take());
						} catch (InterruptedException e) {
							
							e.printStackTrace();
						}
					}
				};
			};

			Thread tOut = new Thread("Bus out") {
				public void run() {
					while (!stopped) {
						// Object[] els = out.get();
						// if (stopped)
						// return;
						// for (Object object : els) {
						// BusAction buse = (BusAction) object;
						// exec.execute(buse);
						// }
						try {
							exec.execute(out.take());
						} catch (InterruptedException e) {
							
							e.printStackTrace();
						}
					}
				};
			};
			tIn.start();
			tOut.start();
		}

		public void stop() {
			stopped = true;
			// in.put(new Object());
			// out.put(new Object());
		}

		public void add(BusAction act) {
			try {
				in.put(act);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
		}

	}

	public void add(String queue, BusAction act) {
		// queue = "ONLY";
		Bus b = buses.get(queue);
		if (b == null) {
			synchronized (this) {
				b = buses.get(queue);
				if (b == null) {
					b = new Bus();
					buses.put(queue, b);
				}
			}
		}
		b.add(act);
	}
}